<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Idempotent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">concurrency</a> &gt; <a href="index.source.html" class="el_package">io.github.jonloucks.concurrency.api</a> &gt; <span class="el_source">Idempotent.java</span></div><h1>Idempotent.java</h1><pre class="source lang-java linenums">package io.github.jonloucks.concurrency.api;

import io.github.jonloucks.contracts.api.AutoClose;
import io.github.jonloucks.contracts.api.AutoOpen;
import io.github.jonloucks.contracts.api.Contracts;

import static io.github.jonloucks.contracts.api.Checks.contractsCheck;
import static io.github.jonloucks.contracts.api.Checks.nullCheck;

/**
 * Idempotent state machine states
 */
<span class="fc" id="L13">public enum Idempotent implements StateMachine.Rule&lt;Idempotent&gt; {</span>
    /**
     * Initial state
     * OPENABLE can transition to OPENED, OPENING, CLOSED, or DESTROYED.
     */
<span class="fc" id="L18">    OPENABLE {</span>
        @Override
        public boolean canTransition(String event, Idempotent goal) {
<span class="fc bfc" id="L21" title="All 8 branches covered.">            return goal == OPENED || goal == OPENING || goal == CLOSED || goal == DESTROYED;</span>
        }
    },
    /**
     * For use cases where the open can take some time or reentrancy calls while initializing.
     * Transitioning to OPENING and then OPENED will allow requests to not be rejected.
     * OPENING can transition to OPENED, CLOSED, OPENABLE, DESTROYED.
     */
<span class="fc" id="L29">    OPENING {</span>
        @Override
        public boolean canTransition(String event, Idempotent goal) {
<span class="fc bfc" id="L32" title="All 8 branches covered.">            return goal == OPENED || goal == CLOSED || goal == OPENABLE || goal == DESTROYED;</span>
        }
        @Override
        public boolean isRejecting() {
<span class="fc" id="L36">            return false;</span>
        }
    },
    /**
     * Resource, service is open to actions
     * OPEN can transition to CLOSING or CLOSED.
     */
<span class="fc" id="L43">    OPENED {</span>
        @Override
        public boolean canTransition(String event, Idempotent goal) {
<span class="fc bfc" id="L46" title="All 4 branches covered.">            return goal == CLOSING || goal == CLOSED;</span>
        }
        @Override
        public boolean isRejecting() {
<span class="fc" id="L50">            return false;</span>
        }
    },
    /**
     * A state of closing or shutting down.
     * Note: isRejecting returns false during while close, but implementation can decide
     * if a new action will be processed.
     * CLOSING can transition to CLOSED or DESTROYED
     */
<span class="fc" id="L59">    CLOSING {</span>
        @Override
        public boolean canTransition(String event, Idempotent goal) {
<span class="fc bfc" id="L62" title="All 4 branches covered.">            return goal == CLOSED || goal == DESTROYED;</span>
        }
    },
    /**
     * A state that all new actions are invalid
     * Implementations can decide to ignore or throw exception, but never be processed.
     * CLOSED can transition to OPENABLE or DESTROYED
     */
<span class="fc" id="L70">    CLOSED {</span>
        @Override
        public boolean canTransition(String event, Idempotent goal) {
<span class="fc bfc" id="L73" title="All 4 branches covered.">            return goal == OPENABLE || goal == DESTROYED;</span>
        }
    },
    /**
     * Represents a permanent end state.
     * Implementations can decide to ignore or throw exception, but never be processed.
     * DESTROYED can not transition
     */
<span class="fc" id="L81">    DESTROYED;</span>
    
    @Override
    public boolean canTransition(String event, Idempotent goal) {
<span class="fc" id="L85">        return false;</span>
    }
    
    /**
     * Determines if new requests/action should be rejected
     *
     * @return true if requests should be rejected.
     * How they are rejected is an implementation decision.
     * A request could be ignored, cause an exception, or be processed differently
     */
    public boolean isRejecting() {
<span class="fc" id="L96">        return true;</span>
    }
    
    /**
     * Create a StateMachine for Idempotency
     * @param contracts the contracts for getting dependencies
     * @return the new StateMachine
     * @throws IllegalArgumentException if contracts is null
     */
    public static StateMachine&lt;Idempotent&gt; createStateMachine(Contracts contracts) {
<span class="fc" id="L106">        final Contracts validContracts = contractsCheck(contracts);</span>
<span class="fc" id="L107">        final StateMachineFactory factory = validContracts.claim(StateMachineFactory.CONTRACT);</span>
<span class="fc" id="L108">        return factory.create( b -&gt; {</span>
<span class="fc" id="L109">            b.initial(OPENABLE);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            for (Idempotent idempotent : Idempotent.values()) {</span>
<span class="fc" id="L111">                b.state(idempotent);</span>
<span class="fc" id="L112">                b.rule(idempotent, idempotent);</span>
            }
<span class="fc" id="L114">        });</span>
    }
    
    /**
     * Assist with an idempotent close
     *
     * @param machine the StateMachine
     * @param close the close
     */
    public static void withClose(StateMachine&lt;Idempotent&gt; machine, AutoClose close) {
<span class="fc" id="L124">        final StateMachine&lt;Idempotent&gt; validMachine = nullCheck(machine, &quot;State machine must be present.&quot;);</span>
<span class="fc" id="L125">        final AutoClose validClose = nullCheck(close, &quot;Close must be present.&quot;);</span>
        
<span class="fc" id="L127">        validMachine.transition(b -&gt; b</span>
<span class="fc" id="L128">            .event(&quot;close&quot;)</span>
<span class="fc" id="L129">            .successState(Idempotent.CLOSED)</span>
<span class="fc" id="L130">            .successValue(() -&gt; validClose.close())</span>
<span class="fc" id="L131">            .failedValue(() -&gt; Void.TYPE)</span>
<span class="fc" id="L132">            .errorValue(() -&gt; Void.TYPE));</span>
<span class="fc" id="L133">    }</span>
    
    /**
     * Assist with an idempotent close
     * @param machine the state machine
     * @param open the open
     * @return the AutoClose
     */
    public static AutoClose withOpen(StateMachine&lt;Idempotent&gt; machine, AutoOpen open) {
<span class="fc" id="L142">        final StateMachine&lt;Idempotent&gt; validMachine = nullCheck(machine, &quot;State machine must be present.&quot;);</span>
<span class="fc" id="L143">        final AutoOpen validOpen = nullCheck(open, &quot;Open must be present.&quot;);</span>
        
<span class="fc" id="L145">        return validMachine.transition(b -&gt; b</span>
<span class="fc" id="L146">            .event(&quot;open&quot;)</span>
<span class="fc" id="L147">            .successState(Idempotent.OPENED)</span>
<span class="fc" id="L148">            .successValue(validOpen::open)</span>
<span class="fc" id="L149">            .failedValue(() -&gt; AutoClose.NONE)</span>
        );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>